# discord-bot-js
Discord bot with discord.js for private server.

## Starting the Bot
When starting, you should always do the following things:
1. Make sure you're branched correctly.
2. Pull changes from GitHub.
3. Update packages using `npm install` in terminal.
4. When launching the bot, only if there are new commands or there are commands with updated structures, run `npm run deploy`.
5. Run `npm run main` to launch the bot; and press `Ctrl+C` in the terminal to stop it again.

## Useful Documentation
General documentation on the Discord API (used by packages) can be found [here](https://discord.com/developers/docs).
Documentation for the most important packages used:
- [discord.js](https://discord.js.org/#/) and some subpackages (@discordjs/voice, @discordjs/rest, @discordjs/player) for general Discord support.
- [discord-player](https://discord-player.js.org/) and a subpackage (@discord-player/extractor) to be able to stream music to Discord.
- [node-schedule](https://github.com/node-schedule/node-schedule#cron-style-scheduling) to run code at a specific time each day, week or month.

## Functionality
### Commands
Our bot currently has four commands. The "/ping" command sort of lets you know your and the bot's ping; although it's accuracy is very much up for debate. With "/play" you can make the bot play music in a voice channel you're in. "/create-voice-channel" (which is coded in create_private_conversation.js) can be used to temporarily create additional voice channels. And finally, with "/access enable" and "/access disable", users can add or remove themself from roles, allowing them to acces more or less channels about specific subjects.

The "/ping" command (see [ping.js](./commands/ping.js)) provides two things: the user's (theoretical) ping and the ping between the bot and the API. The user's ping is calculated by subtracting the time at which the interaction (which the official name of the *thing* that the bot receives when a user uses any kind of command in Discord) was send from the time it is now. The time when the interaction is send is calculated from the interaction ID. Almost everything in Discord gets assigned an ID when created. The format of this ID is called snowflake, and part of it consists of the timestamp of creation (if you enable "dev mode" in discord, you can copy IDs of almost everythiong buy right clicking). Therefore we can calculate the moment the interaction was created form it's ID. The bot-API ping is calculated by discord.js. Both are returned to the user in an ephemeral interaction response, a response only the user who created the interaction will be able to see. Ephermeral messages can be deleted by the user, and will be deleted automatically by Discord when unfocussing the channel they are send in. Ephemeral messages can, however, only be send as responses to interactions.

The "/create-voice-channel" command (see [create_private_conversation.js](./commands/create_private_conversation.js)) is also pretty easy. It differentiates between four scenarios, based on wether or not the user who used the command is in a voice channel, and wether or not they set a maximum user size for the new channel. The code then creates a new channel in the guild (which is the word Discord uses for servers) and sets it properties: channel name, type (a voice channel), reason for it's creation, position (where in the list of channels it should be), permissions (what users can and can't do in these channels) and optionally a maximum user size. If the user was already in a voice channel, they get moved to the new channel. The reply to the command gets edited and we save the voice channel in the "global" list of voice channels (`client.temporaryVoiceChannels`).
The reason we "edit" the reply and not "send" it, is because for every command (one of) the first thing(s) you should do is always `interaction.deferReply({})` (or `interaction.deferReply({ ephemeral: true })` if you only want the user who used the command to see the reply). To the user, this'll just show like a "BOT is thinking..." message. However, if you don't run this code as soon as possible, the interaction will "expire" almost immediatly. After the deferReply, the interaction won't expire until 15 minutes afterwards.

The "/access" commands consists of two subcommands: "/access enable" and "access disable". However, both are really easy. In both cases, we take the name of the role the user wanted to be added to or removed from. We then convert it to that role's ID through an object (quick and dirty). The object has two sets of keys, one for the testing server and one for the main server. We than add or remove that role to the user and edit the reply to the interaction.

Maybe the most difiicult of all, is the "/play" command. First, we check wether the user is in a voice channel. Than, if he is, we check wether the bot is "available" (in other words, we make sure the bot is not already playing music in a diffrent channel). We get the search terms the user gave and save them as a variable "query". Then we either create a queue, or add to an existing queue (both are done with the `player.createQueue(...)`-command and I don't fully understand why either, but it works). We create a function that will run before we start playing, and if the music is comming from youtube we use the PlayDL-package to convert that youtube video to something discord understands. We then try to connect the bot to a voice channel. We look for the query the user entered, than take the first track of the results, and then use the aforementioned function to convert music from youtube. Then, we check wether the song is longer than 15 minutes. If it is, we can't play it because by the time it would have ended, the interaction would have expired even though we used "deferReply". If this is the case, we send an error back to the user. If it isn't, we also check wether the queue would become longer than 15 minutes (for the same reason). Theoretically, we could "renew" the interactions after every song, and this problem would be solved. However, I haven't gotten around to doing this yet :). Finally, we start playing and edit the reply.

### Context Menus
There are only two context menu commands, both for reporting things that go against the server rules. One for messages, on for users in general. You can run these commands in Discord by right clicking a message or user, and selecting "Report Message" or "Report User" under "Apps". In both cases, when it's run, the first thing the command does is add a "report" object to the `client.messageReports` or `client.userReports` arrays. For messages, it saves the target message ID, the target message itself, the user that made the report, the reason (unknown at first) and wether action has been taken (false at first). For users, it saves the ID of the reported user, the reported user itself, the reported member itself (user is an object that describes an account on Discord in general, member is an object that describes an account in our specific guild/server), the ID of the user that made the report, the reason (unknown at first) and wether action has been taken (false at first). It than asks the user the reason for the report (in orther words the rule that was broekn) in a drop-down menu. If the user that reported isn't an administrator, a message describing the report is send to #blocked-messages. If the user is an administrator, the message gets deleted (if a message was reported), a message describing the report is send to #blocked-messages and a message explaining what they did wrong is send in DM to the user reported.

### Aditional Functions in [index.js](./index.js)
#### Gif Filter
The code in this sections runs automatically every time a message is send somewhere in our guild. It then checks wether the message contains a gif (".gif", "tenor.com", "giphy.com", "imgur.com"). If it does, it checks wether the message was send in #gifs-and-memes or #adult-content; and if so it ignores the message. Otherwise, the last 90 messages in that channel are loaded and checked on wether they contain other gif-containing messages from the same user. If there are less than 3, it ignores the messages. Otherwise, it gets the "gif violation level" (a level tracked for each user indicating how many times they have reached the gif limit of 3 since midnight). If there is no such level yet (which means the user is at level 0), the level gets added/raised to 5. If the level was already between 1 and 5, the user gets timed out for 10s, 1min, 5min, 10min, 60min, untill midnight). If the time-out length is longer than 1 minute, 15 seconds are subtracted because of a bug with Discord. If the user somehow does it again within the same day (theoratically impossible) they will get timed-out for 24 hours. Then, all (normally 3) gif messages from that user get removed.